<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: viewmodels/usePlayersViewModel.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: viewmodels/usePlayersViewModel.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module ViewModels/usePlayersViewModel
 * @description ViewModel React Hook per la gestione delle liste di giocatori.
 * Gestisce il caricamento paginato (Lazy Loading), la deduplicazione dei dati e il caching per contesto.
 * Supporta tre modalità di funzionamento in base ai parametri URL:
 * 1. Per Squadra: Carica la rosa di un club specifico.
 * 2. Per Lega: Carica i giocatori di un campionato.
 * 3. Top Players (Global): Se nessun ID è fornito, carica i top scorer dei maggiori campionati europei.
 * Pattern implementati:
 * - Infinite Scroll (gestione paginazione progressiva)
 * - Request Throttling (semaforo `isFetching`)
 * - Context-Aware Caching (chiavi di cache differenziate per contesto)
 */
import { useState, useEffect, useCallback, useRef } from 'react';
import { useParams } from 'react-router-dom';
import PlayerService from '../services/PlayerService';
import { Player } from '../models/Player';

/**
 * Hook per la gestione della lista giocatori.
 * * @function usePlayersViewModel
 * @param {string} [externalSearchTerm=""] - Termine di ricerca opzionale per filtrare la lista localmente.
 * @returns {Object} Stato della lista giocatori.
 * @returns {Array&lt;Player>} return.players - Lista filtrata dei giocatori caricati.
 * @returns {boolean} return.loading - Flag di caricamento in corso.
 * @returns {Function} return.loadMore - Funzione per richiedere il caricamento della pagina successiva.
 * @returns {boolean} return.hasMoreRemote - Indica se ci sono altre pagine da caricare dall'API.
 */
export function usePlayersViewModel(externalSearchTerm = "") {
  /** 
   *  Parametri URL per il contesto 
   * @type {Array}
  */
  const { serieId, squadraId } = useParams();

  /** 
   * Stato locale dei giocatori
   *  @type {Array}
   */
  const [players, setPlayers] = useState([]);

  /** 
   * Stato di caricamento 
   *  @type {Array}
  */
  const [loading, setLoading] = useState(true);

  /** 
   * Indice della pagina corrente (Batch)
   *  @type {Array}
   *  */
  const [batchIndex, setBatchIndex] = useState(serieId || squadraId ? 1 : 0);

  /** 
   * Flag per indicare la disponibilità di altri dati remoti  
   * @type {Array}
   * */
  const [hasMoreRemote, setHasMoreRemote] = useState(true);

  const isFetching = useRef(false);

  // Reset stato al cambio contesto (es. cambio squadra o campionato)
  useEffect(() => {
    setPlayers([]);
    setBatchIndex(serieId || squadraId ? 1 : 0);
    setHasMoreRemote(true);
    setLoading(true);
    isFetching.current = false; 
  }, [serieId, squadraId]);

  /**
   * Carica un batch di giocatori.
   * Gestisce la logica di cache (localStorage) e decide quale endpoint del Service chiamare.
   * * @param {number} indexToLoad - Il numero di pagina o indice del batch da caricare.
   */
  const loadPlayers = useCallback(async (indexToLoad) => {
    setLoading(true);
   
    try {
      let newRawData = [];
      let isCacheDump = false;

      if (squadraId || serieId) {
        // --- LOGICA CONTESTUALE (SQUADRA o LEGA) ---
        const contextKey = squadraId ? `team_${squadraId}` : `league_${serieId}`;
        const cacheKey = `players_${contextKey}_p${indexToLoad}`;
        const cachedData = localStorage.getItem(cacheKey);

        if (cachedData) {
          newRawData = JSON.parse(cachedData);
        } else {
          // Service gestisce deduplicazione chiamate
          newRawData = squadraId 
            ? await PlayerService.getPlayersByTeam(squadraId, 2024, indexToLoad)
            : await PlayerService.getPlayersByLeague(serieId, 2024, indexToLoad);
          
          if (newRawData &amp;&amp; newRawData.length > 0) {
            localStorage.setItem(cacheKey, JSON.stringify(newRawData));
          } else {
             console.warn(`API returned empty list for ${squadraId ? 'Team' : 'League'} ID: ${squadraId || serieId}, Page: ${indexToLoad}`);
          }
        }
        
        // Se non ci sono dati o limite pagina API free raggiunto (page > 3), stop.
        if (!newRawData || (Array.isArray(newRawData) &amp;&amp; newRawData.length === 0)) {
          setHasMoreRemote(false);
        }
        if (indexToLoad >= 3) {
          setHasMoreRemote(false);
        }
      } else {
        // --- LOGICA GLOBAL TOP PLAYERS ---
        if (indexToLoad &lt; 5) {
          const leagueId = PlayerService.topLeagues[indexToLoad]?.id;
          const cacheKey = `players_global_top_${leagueId}`;
          const cachedData = localStorage.getItem(cacheKey);
          if (cachedData) {
            newRawData = JSON.parse(cachedData);
          } else {
            newRawData = await PlayerService.getTopPlayersBatch(indexToLoad);
            if (newRawData &amp;&amp; newRawData.length > 0) localStorage.setItem(cacheKey, JSON.stringify(newRawData));
          }
        } else {
          // Recupero "Cache Dump": mostra tutto ciò che è stato visitato in precedenza
          isCacheDump = true;
          setHasMoreRemote(false);
        }
      }

      // Aggiornamento Stato
      if (isCacheDump) {
        const allCached = [];
        for (let i = 0; i &lt; localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key?.startsWith('players_')) {
            const data = JSON.parse(localStorage.getItem(key));
            if (Array.isArray(data)) allCached.push(...data);
          }
        }
        setPlayers(prev => {
          const currentIds = new Set(prev.map(p => p.id));
          const uniqueRest = allCached.map(item => new Player(item)).filter(p => !currentIds.has(p.id));
          return [...prev, ...uniqueRest];
        });
      } else if (newRawData &amp;&amp; newRawData.length > 0) {
        const newPlayers = newRawData.map(item => new Player(item));
        setPlayers(prev => {
          // Se è la prima pagina, sostituisci. Altrimenti appendi.
          const isInitialLoad = indexToLoad === (serieId || squadraId ? 1 : 0);
          const combined = isInitialLoad ? newPlayers : [...prev, ...newPlayers];
          // Deduplicazione finale tramite Map
          return Array.from(new Map(combined.map(p => [p.id, p])).values());
        });
      }
    } catch (error) {
      console.error("Errore loadPlayers:", error);
      setHasMoreRemote(false);
    } finally {
      setLoading(false);
      isFetching.current = false;
    }
  }, [serieId, squadraId]); 

  // Trigger caricamento al cambio di batchIndex
  useEffect(() => {
    if (hasMoreRemote || batchIndex === 0) {
      loadPlayers(batchIndex);
    }
  }, [batchIndex, loadPlayers, hasMoreRemote]);

  /**
   * Incrementa l'indice del batch per caricare la pagina successiva.
   * Viene chiamata dall'Infinite Scroll della View.
   */
  const handleLoadMore = () => {
    // Se stiamo già caricando (isFetching.current è TRUE), ignoriamo la richiesta
    if (loading || !hasMoreRemote || isFetching.current) return;
    
    isFetching.current = true; 
    setBatchIndex(prev => prev + 1);
  };

  return {
    players: players.filter(p => p.name.toLowerCase().includes(externalSearchTerm.toLowerCase())),
    loading,
    loadMore: handleLoadMore,
    hasMoreRemote
  };
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-App.html">App</a></li><li><a href="module-Index.html">Index</a></li><li><a href="module-Models_Player.html">Models/Player</a></li><li><a href="module-Services_PlayerService.html">Services/PlayerService</a></li><li><a href="module-ViewModels_useApiUsageViewModel.html">ViewModels/useApiUsageViewModel</a></li><li><a href="module-ViewModels_useNationalTeamsViewModel.html">ViewModels/useNationalTeamsViewModel</a></li><li><a href="module-ViewModels_useNationsViewModel.html">ViewModels/useNationsViewModel</a></li><li><a href="module-ViewModels_usePlayerDetailViewModel.html">ViewModels/usePlayerDetailViewModel</a></li><li><a href="module-ViewModels_usePlayersViewModel.html">ViewModels/usePlayersViewModel</a></li><li><a href="module-ViewModels_useSearchViewModel.html">ViewModels/useSearchViewModel</a></li><li><a href="module-ViewModels_useSeriesViewModel.html">ViewModels/useSeriesViewModel</a></li><li><a href="module-ViewModels_useTeamsViewModel.html">ViewModels/useTeamsViewModel</a></li></ul><h3>Classes</h3><ul><li><a href="module-Models_Player.Player.html">Player</a></li><li><a href="module-Services_PlayerService-PlayerService.html">PlayerService</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Fri Feb 13 2026 17:37:27 GMT+0100 (Ora standard dell’Europa centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
